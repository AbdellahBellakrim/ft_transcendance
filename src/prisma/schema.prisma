// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Status {
  IN_GAME
  ONLINE
  OFFLINE
}

model User {
  id       String @id @default(uuid())
  username String @unique
  email    String @unique
  password String
  avatar   String //(1)in the default of user we re going to give it a default path location of a default user
  
  status  Status @default(ONLINE)

  match_host  match[] @relation("Player1")
  match_guest match[] @relation("Player2")

  stats   Stats?
  invited Friendships[] @relation("invited")
  invitor Friendships[] @relation("invitor")

  initiator DirectMessaging[] @relation("initiator")
  receiver DirectMessaging[] @relation("receiver")

  channels ChannelMembership[]
  messages Message[]

  notifications Notification[]
}


model match {
  id String @id @default(uuid())

  player_1    User   @relation("Player1", fields: [player_1_id], references: [id])
  player_1_id String 

  player_2    User   @relation("Player2", fields: [player_2_id], references: [id])
  player_2_id String
  result      String
}


model Stats {
  id      String @id @default(uuid())
  user    User   @relation(fields: [user_id], references: [id])
  user_id String @unique

  wins         Int @default(0)
  losses       Int @default(0)
  ladder_level Int @default(0)
}


enum RelationStatus {
  PENDING
  FRIENDS
  BLOCK
}

model Friendships {
  id      String @id @default(uuid())
  user1    User   @relation("invited", fields: [user1_id], references: [id])
  user1_id String @unique

    user2    User   @relation("invitor", fields: [user2_id], references: [id])
    user2_id String @unique

    created_at  DateTime @default(now())
    relationStatus RelationStatus  @default(PENDING)
}


enum Role {
  OWNER
  ADMIN
  USER
}

model ChannelMembership {
  id String @id @default(uuid())

  channel    Channel @relation(fields: [channel_id], references: [id])
  channel_id String  @unique

  user    User   @relation(fields: [user_id], references: [id])
  user_id String @unique

  role      Role
  joined_at DateTime @default(now())

  is_banned Boolean @default(false)
  banned_at DateTime?
}

model Message {
  id String @id @default(uuid())

  user    User   @relation(fields: [user_id], references: [id])
  user_id String @unique

  channel    Channel  @relation(fields: [channel_id], references: [id])
  channel_id String   @unique
  created_at DateTime @default(now())
  content    String
  is_read    Boolean  @default(false)
}

enum Channel_type {
  PUBLIC
  PRIVATE
  PROTECTED
}

model Channel {
  id String @id @default(uuid())

  type         Channel_type
  name         String
  image        String //(2)this attribiute is for storing image location in filesystem also check (1)
  memeberShips ChannelMembership[]
  messages     Message[]
  password     String?
  created_at DateTime @default(now())
  updated_at   DateTime @default(now())
}

enum DmStatus {
  ALLOWED
  BANNED
}

model DirectMessaging {
  id String @id @default(uuid())

  
  user1     User   @relation("initiator", fields: [user1_id], references: [id])
  user1_id  String @unique

  user2     User   @relation("receiver", fields: [user2_id], references: [id])
  user2_id  String @unique
  status    DmStatus @default(ALLOWED)
  created_at DateTime @default(now())
  updated_at DateTime @default(now())
}


enum NotificationType {
  ACCEPTED_INVITATION
  GAME_INVITATION
}

model Notification {
  id String @id @default(uuid())

  user    User   @relation(fields: [user_id], references: [id])
  user_id String @unique

  //I still don't know how the source notification will be like
  type       NotificationType
  created_at DateTime         @default(now())
}

//here are the CRUD (Create, Read, Update, Delete) operations for the different entities based on the provided project overview:

// User Account Operations:

// Create:

// Create a new user account upon registration.
// Read:

// Retrieve user information by user ID.
// Retrieve user information by username.
// Retrieve user's friends list and their statuses.
// Retrieve user stats (wins, losses, ladder level, achievements, etc.).
// Retrieve user's match history.
// Update:

// Update user information (avatar, two-factor authentication settings, etc.).
// Update user stats (wins, losses, ladder level, achievements, etc.).
// Delete:

// Delete a user account.
// Chat Operations:
// 5. Create:

// Create a new chat channel (public, private, or password-protected).
// Assign the channel creator as the channel owner and set the channel password.
//user joins channel

// Read:

// Retrieve chat channels by channel ID.
// Retrieve chat channels by channel type (public, private, password-protected).
// Retrieve direct messages between users.
// Retrieve a user's blocked users list.
// Update:

// Update channel information (e.g., change channel password, remove password protection).
// Update user's blocked users list.
// Delete:

// Delete a chat channel (for channel owners or administrators).
// Delete direct messages.
// Game Operations:
// 9. Create:

// Create a new game record when a Pong game is played.
// Create customization options for games (power-ups, maps).
// Read:

// Retrieve game records by game ID.
// Retrieve game records by user ID (e.g., match history).
// Retrieve default game settings.
// Update:

// Update game records (e.g., results, customizations).
// Delete:

// Delete game records (if required).
// Remember that the actual implementation of these CRUD operations will involve using database queries, transactions, and appropriate NestJS modules (such as TypeORM or Prisma) to interact with the PostgreSQL database and perform the necessary data manipulation. Additionally, you'll need to handle input validation and ensure the security measures mentioned in the project overview, such as password hashing and protection against SQL injections.



//update frienship ( friends, block .. )